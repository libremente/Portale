<?
include_once(LIBS.'/Data/DataStruct.php');
include_once(LIBS.'/Data/TypeSpace.php');
include_once(LIBS.'/Data/BindingManager.php');
include_once(LIBS.'/Data/Db/Binding_db.php');


class Builder_db extends DataManager_db{
  var $nameSpace;
  var $tableName;
  var $dbFields;
  var $bindingData;
  var $refTables;
  var $dbType;
  var $basePath;
  var $bindingXML;
  var $history;

  function Builder_db($structName){
    parent::DataManager_db($structName);
    $this->setPath();
    $this->config['deleteUnused'] = true;
    $this->reservedKeywords['sql'] = array('TO', 'KEY');
    $this->reserverKeywords['oracle'] = array('FILE');
  }
  
  function init(){
    $this->struct = $this->typeSpace->getStructure($this->structName);
  }
  
  function setPath(){
    list($accessMode, $nameSpace, $localName, $dir) = parseClassName($this->structName);
    $this->nameSpace = $nameSpace;
    if (!$nameSpace || $nameSpace == 'base') $this->basePath = BASE;
    else $this->basePath = APPS.'/'.$nameSpace;
  }

  function getBindingPath(){
    if ((!$this->nameSpace || $this->nameSpace == 'base') && defined('BASE_BINDINGS')){
      $bindingPath = BASE_BINDINGS;
    }
    elseif ($this->nameSpace && defined('APPS_BINDINGS')){
      $bindingPath = APPS_BINDINGS.'/'.$this->nameSpace;
    }
    else $bindingPath = $this->basePath.'/structs/bindings';
    return $bindingPath;
  }

  function getBindingFile(){
    $this->init();
    $bindingFile = $this->getBindingPath().'/'.$this->struct->localName.'-db.xml';
    return $bindingFile;
  }

  function isAutoGenerated(){
    $bindingFile = $this->getBindingFile();
    if (!file_exists($bindingFile)) return true;
    $dom = new DOMDocument();
    $dom->load($bindingFile);
    $root = $dom->documentElement;
    $autogen = $root->getAttribute('autogen');
    if ($autogen) return true;
    return false;
  }
  
  function writeBinding($file){
    global $IMP;
    $IMP->debug("Writing binding file: $file", 4);
    $this->bindingXML->save($file);
  }
  
  function build($generateBinding=true){
    $this->init();
    $bindingFile = $this->getBindingFile();
    $this->parseBinding($bindingFile);
    if ($generateBinding || $bindingFile){
      $this->parseStruct();
      if ($this->isAutoGenerated()) $this->writeBinding($bindingFile);
    }
    if (!$this->bindingData['external'] || $this->bindingData['syncDb']){
//    if (!$this->bindingData['external']){
      $this->fixTable($this->tableName, $this->dbFields);
      if (is_array($this->refTables)) foreach ($this->refTables as $table => $fields){
        $this->fixTable($table, $fields);
      }
    }
    $securityFields['ID']['type'] = 'int';
    $securityFields['SID']['type'] = 'int';
    $securityFields['USER']['type'] = 'int';
    $securityFields['GRP']['type'] = 'int';
    $securityFields['R']['type'] = 'int';
    $securityFields['W']['type'] = 'int';
    $securityFields['STRUCT']['type'] = 'int';
    #$this->fixTable('P_'.$this->tableName, $securityFields);
  }
  
  function parseBinding($bindingFile){
    $this->bindingData = array();
    if (!file_exists($bindingFile)) return;
    $dom = new DOMDocument();
    $dom->load($bindingFile);
    $root = $dom->documentElement;
    $children = $root->childNodes;
    $this->bindingData['autogen'] = $root->getAttribute('autogen');
    $this->bindingData['external'] = $root->getAttribute('external');
    $this->bindingData['syncDb'] = $root->getAttribute('syncDb');
    foreach ($children as $child){
      $entity = $child->nodeName;
      if ($entity == 'table') $this->bindingData['tableName'] = $child->textContent;
      elseif ($entity == 'bind'){
        $element = $child->getAttribute('element');
        $dbField = $child->getAttribute('dbField');
        $this->bindingData['fields'][$element] = $dbField;
      }
      elseif ($entity == 'mmbind'){
          $element = $child->getAttribute('element');
          $mmBindTable = $child->getAttribute('table');
          $mmBindLocalId = $child->getAttribute('local_id');
          $mmBindRemoteId = $child->getAttribute('remote_id');
          $this->bindingData['mm'][$element] = array(
              'table' => $mmBindTable,
              'local_id' => $mmBindLocalId,
              'remote_id' => $mmBindRemoteId
          );
      }
    }
  }
  
  function parseStruct(){
    global $IMP;
    $structName = $this->structName;
    $IMP->debug("Parsing struct $structName", 4);
    if ($this->bindingData['external'] && $this->bindingData['tableName']){
      $tableName = $this->bindingData['tableName'];
    }
    else{
      $tableName = strtr($structName, ':', '_');
      $tableName = strtr($tableName, '.', '_');
      $tableName = strtoupper($tableName);
      $tableName = str_replace('ICI__', '', $tableName);
    }
    $binding = $this->bindingManager->getBinding($this->structName, 1);
    if ($binding) $dbType = $binding->dbType;
    else $dbType = $IMP->defaults['dbType'];
    $this->dbType = $dbType;
    $tableName = $this->fixTableName($tableName, $dbType);
    $this->tableName = $tableName;
    $xmlDoc = new DOMDocument();
    $xmlDoc->loadXML('<?xml version="1.0" encoding="iso-8859-1" ?><binding type="db" autogen="true"></binding>');
    $node = $xmlDoc->createElement('binding');
    $xmlRoot = $xmlDoc->documentElement;
    $node = $xmlDoc->createElement('table');
    $node->appendChild($xmlDoc->createTextNode($tableName));
    $xmlRoot->appendChild($node);
    $struct = & $this->typeSpace->getStructure($structName);
    $this->struct = $struct;
    $this->clearFields();
    $this->addField('PERMS', 'VARCHAR', 50);
    if (!$this->bindingData['external']){
      $this->addField('ID', 'INT');
      $this->addField('CR_DATE', 'VARCHAR', 50);
      $this->addField('MOD_DATE', 'VARCHAR', 50);
      $this->addField('CR_USER_ID', 'INT');
      $this->addField('MOD_USER_ID', 'INT');
    }
    if ($this->bindingData['syncDb']){
      $this->addField('ID', 'INT');
      $this->addField('CR_DATE', 'VARCHAR', 50);
      $this->addField('MOD_DATE', 'VARCHAR', 50);
      $this->addField('CR_USER_ID', 'INT');
      $this->addField('MOD_USER_ID', 'INT');
    }
    foreach ($struct->extends as $parentStruct){
      if (!$this->bindingData['syncDb']) $parentRefChildField = 'ID_'.$tableName;
      $parentTable = strtoupper(strtr($parentStruct, ':', '_'));
      $parentTable = strtr($parentTable, '.', '_');
      if (!$this->bindingData['syncDb']) $parentRefParentField = 'ID_'.$parentTable;
      $parentRefTable = $tableName.'_EXT_'.$parentTable;
      $parentRefTable = $this->fixTableName($parentRefTable, $dbType);
      print "PARENTREF: $parentRefTable<br>";
      $node = $xmlDoc->createElement('parentRef');
      $node->setAttribute('struct', $parentStruct);
      $node->setAttribute('table', $parentRefTable);
      $node->setAttribute('child_id', $parentRefChildField);
      $node->setAttribute('parent_id', $parentRefParentField);
      $refFields = array();
      $refFields['ID']['type'] = 'INT';
      $refFields[$parentRefChildField]['type'] = 'INT';
      $refFields[$parentRefParentField]['type'] = 'INT';
      if (!$this->refTables[$parentRefTable]) $this->refTables[$parentRefTable] = $refFields;
      $xmlRoot->appendChild($node);
    }
    $elements = $struct->getElements();
    foreach ($elements as $element){
      if ($struct->parentElements[$element]) continue;
      if ($struct->inline[$element]){
        $type = $struct->inline[$element];
        if ($this->bindingManager->bindingType($type) == 'db'){
          print "TYPE: $type HAS BINDING ".$this->bindingManager->bindingType($type)."<br>";
          $builder = new Builder_db($type);
          $builder->build();
        }
      }
      else $type = $struct->type($element);
      $IMP->debug("Parsing element $element", 4);
      $encodedName = $struct->getParameter($element, 'encodedName');
      $parameters = $struct->getParameters($element);
      if ( $this->typeSpace->isBaseType($type) ){
        $languages = $this->struct->languages;
        if (sizeof($languages) < 1 || !in_array($type, $this->struct->languageTypes)){
          $languages = array(0);
        }
        foreach ($languages as $lang){
          $dbField = $this->mapElement($element, $type, $parameters, $lang);
          $options = array();
          if ($element == 'id' || in_array($element, $struct->getKeys())) $options['index'] = true;
          if ($element == 'login' && $struct->name == '_security_user') $options['index'] = true;
					$this->addField($dbField['name'], $dbField['type'], $dbField['size'], $options);
          $node = $xmlDoc->createElement('bind');
          $node->setAttribute('element', $encodedName);
          if ($lang) $node->setAttribute('language', $lang);
          $node->setAttribute('dbField', $dbField['name']);
          $xmlRoot->appendChild($node);
        }
      }
      else{
        $otherStruct = $this->typeSpace->getStructure($type);
        if ( $struct->isChildOf($type, $element) && !$otherStruct->extendsType($structName) && !$struct->extend[$element] && !($struct->inline[$element] && $struct->isMultiple($element))){
          print "CHILD OF $element<br>";
          $IMP->debug("{$struct->name} appears to be a child of $type through $element", 4);
          #just add a key for the ID of the foreign structure
          if ($this->bindingData['external'] && $this->bindingData['fields'][$element]){
            $dbFieldName = $this->bindingData['fields'][$element];
          }
          else $dbFieldName = $this->fixForDb('ID_'.strtoupper($element));
          $type = $otherStruct->type('id');
          print "TYPE FOR $element: $type<br>";
          $dbField = $this->mapElement('id', $type);
          $this->addField($dbFieldName, $dbField['type'], $dbField['size'], array('index'=>true));
          $node = $xmlDoc->createElement('bind');
          $node->setAttribute('element', $element);
          $node->setAttribute('dbField', $dbFieldName);
          $xmlRoot->appendChild($node);
        }
        elseif( $otherStruct->isChildOf($structName) && !$struct->extend[$element] && !$struct->inline[$element]){
          print "$element IS A CHILD<br>";
          #do nothing on the db: we will take care of it when dealing with the substruct
          #:TODO: we could add some info about the linking field in $otherStruct to the
          #binding xml. But than again, we don't have more info now than later.
        }
        else{
          #FIXME: creates ref table for extend structs when it's not due
          #default to a mmbind
          print "MM $element<br>";
          $IMP->debug("m2m for {$struct->name} and $type", 4);
          $mmFields = array();
          if ($this->bindingData['mm'][$element]){
              $localField = $this->bindingData['mm'][$element]['local_id'];
              $remoteField = $this->bindingData['mm'][$element]['remote_id'];
              $mmTable = $this->bindingData['mm'][$element]['table'];
          }
          else{
          $typeDbName = strtr($type, ':', '_');
          $typeDbName = strtr($typeDbName, '.', '_');
          $typeDbName = strtoupper($typeDbName);
          $remoteField = 'ID_'.$typeDbName;
          $tmp[0] = $tableName;
          $tmp[1] = $typeDbName;
          sort($tmp);
          $mmTable = $tmp[0].'_REF_'.$tmp[1];
          $mmTable = $this->fixTableName($mmTable, $dbType);
              $localField = 'ID_'.$tableName;    
          }
          $localField = $this->fixForDb($localField);
          $remoteField = $this->fixForDb($remoteField);
          $idFieldName = $this->fixForDb('ID');
          $mmFields[$idFieldName]['type'] = 'INT';
          $mmFields[$idFieldName]['options']['index'] = true;
          $localFieldDetails = $this->mapElement('id', $struct->type('id'));
          $mmFields[$localField] = $localFieldDetails;
          $mmFields[$localField]['options']['index'] = true;
          $remoteFieldDetails = $this->mapElement('id', $otherStruct->type('id'));
          $mmFields[$remoteField] = $remoteFieldDetails;
          $mmFields[$remoteField]['options']['index'] = true;
          $node = $xmlDoc->createElement('mmbind');
          $node->setAttribute('element', $element);
          $node->setAttribute('table', $mmTable);
          $node->setAttribute('local_id', $localField);
          $node->setAttribute('remote_id', $remoteField);
          if (is_array($struct->extend[$element])) foreach (array_keys($struct->extend[$element]) as $extEl){
            $type = $struct->extend[$element][$extEl]['type'];
            if (!$this->typeSpace->isBaseType($type)){
                $extStruct = $this->typeSpace->getStructure($type);
                $type = $extStruct->type('id');
            }
            $params = $struct->extend[$element][$extEl]['parameters'];
            $languages = $this->struct->languages;
            if (sizeof($languages) < 1 || !in_array($type, $this->struct->languageTypes)){
              $languages = array(0);
            }
            foreach ($languages as $lang){  
              $dbField = $this->mapElement($extEl, $type, $params, $lang);
              $mmFields[$dbField['name']]['type'] = $dbField['type'];
              $mmFields[$dbField['name']]['size'] = $dbField['size'];
              $child = $xmlDoc->createElement('bind');
              $child->setAttribute('element', $extEl);
              if ($lang) $child->setAttribute('language', $lang);
              $child->setAttribute('dbField', $dbField['name']);
              $node->appendChild($child);
            }
          }
          if (!$this->refTables[$mmTable] || sizeof($this->refTables[$mmTable]) < sizeof($mmFields)) 
            $this->refTables[$mmTable] = $mmFields;
          $xmlRoot->appendChild($node);
        }
      }  
    }
    $IMP->debug($xmlDoc->saveXML(), 4);
    $this->bindingXML = $xmlDoc;
  }

  function addField($name, $sqlType, $sqlSize=0, $options=0){
    if ($this->dbType == 'oracle'){
      //if ($sqlType == 'VARCHAR') $sqlSize = '';
    }
    if ($this->dbType == 'pgsql'){
        $name = strtolower($name);
    }
    if (!$options) $options = array();
    $this->dbFields[$name] = array('type' => $sqlType, 'size' => $sqlSize, 'options' => $options);
  }

  function clearFields(){
    $this->dbFields = array();
  }
  
  function getDbType($fieldDesc){
    $dbType = $fieldDesc['type'];
    if ($fieldDesc['size']) $dbType .= '('.$fieldDesc['size'].')';
    return $dbType;
  }

  function fixTable($tableName, $fields){
    global $IMP;
    $restoreDebug = $IMP->debugLevel;
    $IMP->debugLevel = 2;
    $binding = $this->bindingManager->getBinding($this->structName);
    $this->db = $binding->getDbObject();
    $table = $this->db->describeTable($tableName);
    $IMP->debug("TABLE $tableName:", 2);
    if ($table) $IMP->debug($table, 2);
    else $IMP->debug('Not found', 2);
    if ($table){
      $aggPerms = true; 
      foreach ($fields as $name => $fieldDesc){
        $dbType = $this->getDbType($fieldDesc);
        if ($name == 'PERMS') $aggPerms = false;
        if (!$table[$name]){
          $sql = "ALTER TABLE $tableName ADD $name $dbType";
          $IMP->debug($sql, 2);
          $this->db->execute($sql);
        }
        elseif ($table[$name]['type'] != $fieldDesc['type'] || $table[$name]['size'] != $fieldDesc['size']){
            if ($this->dbType == 'pgsql'){
                $sql = "ALTER TABLE $tableName ADD {$name}_TMPCOLUMN $dbType";
                $IMP->debug($sql, 2);
                $this->db->execute($sql);
                $sql = "UPDATE $tableName SET {$name}_TMPCOLUMN = {$name}";
                $IMP->debug($sql, 2);
                $this->db->execute($sql);
                $sql = "ALTER TABLE $tableName DROP {$name}";
                $IMP->debug($sql, 2);
                $this->db->execute($sql);
                $sql = "ALTER TABLE $tableName RENAME {$name}_TMPCOLUMN TO $name";
                $IMP->debug($sql, 2);
                $this->db->execute($sql);
            }
            else{
                $sql = "ALTER TABLE $tableName MODIFY $name $dbType";
                $IMP->debug($sql, 2);
                $this->db->execute($sql);
                if ($name == 'ID' && $IMP->config['defaultdb']['type'] == 'mysql' && $IMP->config['nosequenze']){
                  $struct = $this->structName;
                  $binding = $IMP->bindingManager->getBinding($struct);
                  $result = $this->db->execute("SHOW INDEXES FROM {$tableName} WHERE Key_name = 'PRIMARY'");
                  echo "<br>SHOW INDEXES FROM {$tableName} WHERE Key_name = 'PRIMARY'"."\n";
                  echo "<br>returned ".mysql_num_rows($result)." rows\n";
                  if(!$result || @mysql_num_rows($result)<1) {
                    echo "<br>ALTER TABLE `{$tableName}` ADD PRIMARY KEY(`{$name}`)"."\n";
                    echo "<br>".mysql_error()."\n";
                    $this->db->execute("ALTER TABLE `{$tableName}` ADD PRIMARY KEY({$name})");
                   if(mysql_error()) {
                      die("Attenzione: si &egrave; verificato un errore fatale sull'aggiunta della chiave primaria. ".mysql_error());
                    }
                    else {
                      echo "<br>{$tableName} has a primary key"."\n";
                    }
                  }
                  $sql = "ALTER TABLE $tableName CHANGE $name $name INT(11) NOT NULL AUTO_INCREMENT";
                  $IMP->debug($sql, 2);
                  $this->db->execute($sql);
               }
            }
          if ($fieldDesc['options']['index'] && !$table[$name]['index']){
            if ($name == 'ID' && $IMP->config['defaultdb']['type'] == 'mysql' && $IMP->config['nosequenze']){
               echo "<br>Non serve l'indice c'è la chiave primaria";
            }else{
                $sql = "ALTER TABLE $tableName ADD INDEX IDX_$name ($name)";
                $IMP->debug($sql, 2);
                $this->db->execute($sql);
            }
          }
        }
      }
      if ($aggPerms){
        $sql = "ALTER TABLE $tableName ADD PERMS VARCHAR(50)";
        $IMP->debug($sql, 2);
        $this->db->execute($sql);
      }
      if ($this->params['deleteUnused']){
        foreach ( array_keys($table) as $fieldName ){
          if ( !$fields[$fieldName] ){
            $sql = "ALTER TABLE $tableName DROP $fieldName";
            $IMP->debug($sql, 2);
            $this->db->execute($sql);
          }
        }
      }
    }
    else{
      $sql = "CREATE TABLE $tableName ";
      $fieldsSql = '';
      foreach ($fields as $name => $fieldDesc){
        $dbType = $this->getDbType($fieldDesc);
        if ($fieldsSql) $fieldsSql .= ', ';
        $fieldsSql .= "$name $dbType";
      }
      $sql .= "($fieldsSql)";
      $IMP->debug($sql, 2);
      $this->db->execute($sql);
      foreach ($fields as $name => $fieldDesc){
        if ($fieldDesc['index']){
          $sql = "ALTER TABLE $tableName ADD INDEX $name";
          $IMP->debug($sql, 2);
          $this->db->execute($sql);
        }
      }
    }
    if ($fields['ID']['type'] == 'INT'){
      $sql = "SELECT MAX(ID) AS M FROM $tableName";
      print $sql;
      $this->db->execute($sql);
      if ($this->db->fetchrow()){
        $max = $this->db->result('M');
      }
      $max++;
      $maxID = $max;
      $campo = "ID";
//      print "SEQUENCE: $max<br>";
//      $IMP->setIndex($tableName, $max);
    }
    
    // se no sequenze, aggiungere autoincrement a colonna id?
    // ALTER TABLE $tableName MODIFY `ID` INT AUTO_INCREMENT PRIMARY KEY;

    if ($fields['ID_TAB']['type'] == 'INT'){
      $sql = "SELECT MAX(ID_TAB) AS M FROM $tableName";
      $this->db->execute($sql);
      if ($this->db->fetchrow()){
        $max = $this->db->result('M');
      }
      $max++;
      $maxID_TAB = $max;
      $campo = 'ID_TAB';
//      print "SEQUENCE: $max<br>";
//      $IMP->setIndex($tableName, $max);
    }
    if (!$maxID) $maxID = 1;
    if (!$maxID_TAB) $maxID_TAB = 1;
    $max = $maxID;
//     if ($IMP->config['defaultdb']['type'] == 'mysql' && $IMP->config['nosequenze']){
//       $sql = "ALTER TABLE $tableName DROP PRIMARY KEY";
//       print $sql;
//       $this->db->execute($sql);
//       $sql = "ALTER TABLE $tableName MODIFY {$campo} INT(11) AUTO_INCREMENT PRIMARY KEY";
//       print $sql;
//       $this->db->execute($sql);
//     }

    if ($IMP->config['defaultdb']['type'] == 'mysql' && $IMP->config['nosequenze'] && (substr($binding->id, 0,2) == 'ID') && ($fields[$binding->id]['type'] == 'INT')){
      $struct = $this->structName;
      $binding = $IMP->bindingManager->getBinding($struct);

      echo "<br>table is $tableName and struct is $struct";

      echo "<br>struct $struct\n";
      // devo verificare se la tabella ha primary key
      $result = $this->db->execute("SHOW INDEXES FROM {$tableName} WHERE Key_name = 'PRIMARY'");
      echo "<br>SHOW INDEXES FROM {$tableName} WHERE Key_name = 'PRIMARY'"."\n";
      echo "<br>returned ".mysql_num_rows($result)." rows\n";
      if(!$result || @mysql_num_rows($result)<1) {
	// e se non ce l'ha gliela aggiungo
	      echo "<br>ALTER TABLE `{$tableName}` ADD PRIMARY KEY(`{$binding->id}`)"."\n";
	      echo "<br>".mysql_error()."\n";
	      $this->db->execute("ALTER TABLE `{$tableName}` ADD PRIMARY KEY(`{$binding->id}`)");
	      if(mysql_error()) {
	  // ABORT! non posso aggiungere la chiave primaria! Probabilmente ci sono chiavi duplicate in db
	  // forzo la fine dello script
	       die("Attenzione: si &egrave; verificato un errore fatale sull'aggiunta della chiave primaria. ".mysql_error());
	      }
      } else {
	      echo "<br>{$tableName} has a primary key"."\n";
      }
      
      // idem per l'auto increment che senò mysql_insert_id() restituirà sempre 0
//       $IMP->debugLevel = 9;
       $result = $this->db->execute("select * from INFORMATION_SCHEMA.COLUMNS where table_name='{$tableName}' and table_schema='{$binding->dbConnectionParams['name']}' and column_name='{$binding->id}' and EXTRA like '%auto_increment%'");
      echo "<br>select * from INFORMATION_SCHEMA.COLUMNS where table_name='{$tableName}' and table_schema='{$binding->dbConnectionParams['name']}' and column_name='{$binding->id}' and EXTRA like '%auto_increment%'"."\n";
      echo "<br>returned ".mysql_num_rows($result)." rows\n";
//       echo "<br>error: ".mysql_error()."\n";
//       echo "<br>query result: ".print_r(mysql_fetch_assoc($result),true)."\n";
      if(!$result || @mysql_num_rows($result)<1) {
	$this->db->execute("ALTER TABLE `{$tableName}` CHANGE `{$binding->id}` `{$binding->id}` INT( 11 ) NOT NULL AUTO_INCREMENT ");
	echo "<br>ALTER TABLE `{$tableName}` CHANGE `{$binding->id}` `{$binding->id}` INT( 11 ) NOT NULL AUTO_INCREMENT "."\n";
	if(mysql_error()) {
	  // ABORT! non posso aggiungere la chiave primaria! Probabilmente ci sono chiavi duplicate in db
	  // forzo la fine dello script
	  die("Attenzione: si &egrave; verificato un errore fatale sull'aggiunta della chiave primaria auto_increment. ".mysql_error());
	}
      } else {
	echo "<br>{$tableName} has auto increment"."\n";
      }
//       $IMP->debugLevel = false;
    }
    else{
      // elimino auto_increment e primary key
/*      echo "<br>ALTER TABLE `{$tableName}` CHANGE `{$binding->id}` `{$binding->id}` INT( 11 ) NOT NULL\n";
      $this->db->execute("ALTER TABLE `{$tableName}` CHANGE `{$binding->id}` `{$binding->id}` INT( 11 ) NOT NULL");
      echo "<br>ALTER TABLE `{$tableName}` DROP PRIMARY KEY(`{$binding->id}`\n";
      $this->db->execute("ALTER TABLE `{$tableName}` DROP PRIMARY KEY(`{$binding->id}`)");*/
      if ($maxID_TAB > $maxID) $max = $maxID_TAB;  
      print "SEQUENCE: $max<br>";
      $IMP->setIndex($tableName, $max);
    }
    $IMP->debugLevel = $restoreDebug;
  }
  
  
  function mapElement($element, $type, $parameters=0){
    global $IMP;
    $binding = $this->bindingManager->getBinding($this->structName, 1);
    if ($binding) $dbType = $binding->dbType;
    else $dbType = $IMP->defaults['dbType'];
    switch ($type){
      case 'text':
      case 'password':
      case 'email':
      case 'img':
      case 'file':
      case 'phpelican':
        $sqlType = 'VARCHAR';
        $sqlSize = 150;
        break;
      case 'longText':
      case 'richText':
      case 'html':
        if ($dbType == 'oracle'){
	        $sqlType = 'VARCHAR';
	        $sqlSize = 4000;
	      }
        else $sqlType = 'LONGTEXT';
        break;
      case 'int':
      case 'id':
      case 'bool':
      case 'order':
        $sqlType = 'INT';
        break;
      case 'dateTime':
        $sqlType = 'CHAR';
        $sqlSize = 19;
        break;
      case 'time':
        $sqlType = 'CHAR';
        $sqlSize = '5';
        break;
      case 'real':
        $sqlType = 'DECIMAL';
        $sqlSize = '20,4';
        break;
      case 'money':
        $sqlType = 'DECIMAL';
	      $sqlSize = '20,2';
        break;
    }
    if ($parameters['size']) $sqlSize = $parameters['size'];
    if ($language) $element .= '_'.$language;
    if ($this->bindingData['external'] && $this->bindingData['fields'][$element]){
      $dbField['name'] = $this->bindingData['fields'][$element];
    }
    else{
      $dbField['name'] = $this->fixForDb($element);
    }
    $dbField['type'] = $sqlType;
    $dbField['size'] = $sqlSize;
    return $dbField;
  }
  
  function fixForDb($string){
    global $IMP;
    $binding = $this->bindingManager->getBinding($this->structName, 1);
    if ($binding) $dbType = $binding->dbType;
    else $dbType = $IMP->defaults['dbType'];
    if ($string == 'read') $string = 'R';
    if ($string == 'write') $string = 'W';
    $string =  strtoupper(remove_accents($string));
    if (in_array($string, $this->reservedKeywords['sql']) || 
        (is_array($this->reservedKeywords[$dbType]) && in_array($string, $this->reservedKeywords[$dbType]))){
        $string .= '_FIELD';
    }
    if ($this->dbType == 'pgsql'){
        $string = strtolower($string);
    }
    return $string;
  }
  
  function fixTableName($tableName, $dbType){
    if ($dbType == 'oracle'){
      if ($tableName[0] == '_') $tableName = substr($tableName, 1);
      $newTableName = $tableName;
      if (strlen($newTableName) > 30) $newTableName = str_replace("_", "", $newTableName);
      if (strlen($newTableName) > 30){
        $newTableName = str_replace("EXT", "_", $newTableName);
	      $newTableName = str_replace("REF", "", $newTableName);
      }
      if (strlen($newTableName) < 30) $tableName = $newTableName;
      else{
        $newTableName = '';
        $tokens = explode("_", $tableName);
        foreach ($tokens as $token){
          if (!$token) continue;
	        if ($token == 'EXT') $token = '_';
	        elseif ($token == 'REF') $token = '';
	        else{
	          $token = substr($token, 0, strlen($token)-2);
	        }
	        $newTableName .= $token;
	      }
	      $tableName = $newTableName;
      }
    }
    else $newTableName = $tableName;
    while (strlen($newTableName) > 64){
      $name = '';
      $parts = explode('_', $newTableName);
      foreach ($parts as $part){
        if (preg_match('/(.+[^AEIOU]).+?/', $part, $matches)){
          if ($name) $name .= '_';
          $name .= $matches[1];
        }
	else{
	  if ($name) $name .= '_';
	  $name .= substr($part, 0, -1);
	}
      }
      $newTableName = $name;
    }
    return $newTableName;
  }
  
}



?>
